"use client";

import { useState, useEffect, useCallback } from "react";
import { PromptModeId, DetailLevelId, OutputFormatId } from "@/lib/types";
import { useSpeechRecognition } from "@/hooks/useSpeechRecognition";
import { useClipboard } from "@/hooks/useClipboard";
import Header from "@/components/Header";
import BrowserWarning from "@/components/BrowserWarning";
import VoiceRecorder from "@/components/VoiceRecorder";
import TranscriptEditor from "@/components/TranscriptEditor";
import PromptModeSelector from "@/components/PromptModeSelector";
import ModifierCheckboxes from "@/components/ModifierCheckboxes";
import DetailLevelSelector from "@/components/DetailLevelSelector";
import OutputFormatSelector from "@/components/OutputFormatSelector";
import ContextInput from "@/components/ContextInput";
import PromptPreview from "@/components/PromptPreview";
import ActionBar from "@/components/ActionBar";
import InterviewModal from "@/components/InterviewModal";
import PromptHistory, { HistoryItem } from "@/components/PromptHistory";

const HISTORY_STORAGE_KEY = "tellclaude-history";

export default function Home() {
  // Speech recognition
  const {
    isListening,
    transcript: speechTranscript,
    interimTranscript,
    isSupported,
    startListening,
    stopListening,
    resetTranscript,
  } = useSpeechRecognition();

  // Editable transcript
  const [transcript, setTranscript] = useState("");

  // Prompt settings
  const [mode, setMode] = useState<PromptModeId>("code");
  const [detailLevel, setDetailLevel] = useState<DetailLevelId>("balanced");
  const [outputFormat, setOutputFormat] = useState<OutputFormatId>("structured");
  const [modifiers, setModifiers] = useState<string[]>([]);
  const [contextInfo, setContextInfo] = useState("");

  // Generated prompt
  const [generatedPrompt, setGeneratedPrompt] = useState("");
  const [showPrompt, setShowPrompt] = useState(false);
  const [isGenerating, setIsGenerating] = useState(false);

  // History
  const [history, setHistory] = useState<HistoryItem[]>([]);
  const [activeHistoryId, setActiveHistoryId] = useState<string | null>(null);
  const [historyOpen, setHistoryOpen] = useState(false);

  // Interview modal
  const [showInterview, setShowInterview] = useState(false);

  // Toast
  const [toast, setToast] = useState<string | null>(null);

  // Clipboard
  const { copied, copyToClipboard } = useClipboard();

  // Load history from localStorage
  useEffect(() => {
    try {
      const saved = localStorage.getItem(HISTORY_STORAGE_KEY);
      if (saved) {
        setHistory(JSON.parse(saved));
      }
    } catch (error) {
      console.error("Failed to load history:", error);
    }
  }, []);

  // Save history to localStorage
  useEffect(() => {
    try {
      localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(history));
    } catch (error) {
      console.error("Failed to save history:", error);
    }
  }, [history]);

  // Sync speech transcript
  useEffect(() => {
    if (speechTranscript) {
      setTranscript(speechTranscript);
    }
  }, [speechTranscript]);

  // Browser support check
  const [showBrowserWarning, setShowBrowserWarning] = useState(false);
  useEffect(() => {
    setShowBrowserWarning(!isSupported);
  }, [isSupported]);

  // Add to history
  const addToHistory = useCallback((transcriptText: string, promptText: string, modeId: string) => {
    const newItem: HistoryItem = {
      id: Date.now().toString(),
      timestamp: Date.now(),
      transcript: transcriptText,
      prompt: promptText,
      mode: modeId,
    };
    setHistory((prev) => [newItem, ...prev.slice(0, 49)]); // Keep last 50
    setActiveHistoryId(newItem.id);
  }, []);

  // Generate prompt using API
  const handleGenerate = useCallback(async () => {
    if (!transcript.trim() || isGenerating) return;

    if (isListening) {
      stopListening();
    }

    setIsGenerating(true);
    setShowPrompt(false);

    try {
      const response = await fetch("/api/generate-prompt", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          transcript: transcript.trim(),
          mode,
          detailLevel,
          outputFormat,
          modifiers,
          contextInfo,
        }),
      });

      const data = await response.json();

      if (data.prompt) {
        setGeneratedPrompt(data.prompt);
        setShowPrompt(true);
        addToHistory(transcript.trim(), data.prompt, mode);
        setToast("Prompt generated by Claude Opus 4.5!");
        setTimeout(() => setToast(null), 3000);
      } else {
        throw new Error("No prompt returned");
      }
    } catch (error) {
      console.error("Generation failed:", error);
      setToast("Failed to generate. Please try again.");
      setTimeout(() => setToast(null), 3000);
    }

    setIsGenerating(false);
  }, [transcript, mode, detailLevel, outputFormat, modifiers, contextInfo, isGenerating, isListening, stopListening, addToHistory]);

  // Handle interview completion
  const handleInterviewComplete = useCallback((enhancedPrompt: string) => {
    setGeneratedPrompt(enhancedPrompt);
    setShowPrompt(true);
    addToHistory(transcript.trim(), enhancedPrompt, mode);
    setToast("Enhanced prompt ready!");
    setTimeout(() => setToast(null), 3000);
  }, [transcript, mode, addToHistory]);

  // Select from history
  const handleHistorySelect = useCallback((item: HistoryItem) => {
    setTranscript(item.transcript);
    setGeneratedPrompt(item.prompt);
    setShowPrompt(true);
    setActiveHistoryId(item.id);
    setMode(item.mode as PromptModeId);
    setToast("Loaded from history");
    setTimeout(() => setToast(null), 2000);
  }, []);

  // Delete from history
  const handleHistoryDelete = useCallback((id: string) => {
    setHistory((prev) => prev.filter((item) => item.id !== id));
    if (activeHistoryId === id) {
      setActiveHistoryId(null);
    }
  }, [activeHistoryId]);

  // Clear all history
  const handleHistoryClear = useCallback(() => {
    setHistory([]);
    setActiveHistoryId(null);
  }, []);

  // Copy prompt
  const handleCopy = useCallback(async () => {
    if (generatedPrompt) {
      const success = await copyToClipboard(generatedPrompt);
      if (success) {
        setToast("Copied to clipboard! Paste into Claude Code.");
        setTimeout(() => setToast(null), 3000);
      }
    }
  }, [generatedPrompt, copyToClipboard]);

  // Clear transcript
  const handleClear = useCallback(() => {
    setTranscript("");
    resetTranscript();
  }, [resetTranscript]);

  // Reset everything
  const handleReset = useCallback(() => {
    if (isListening) {
      stopListening();
    }
    setTranscript("");
    resetTranscript();
    setGeneratedPrompt("");
    setShowPrompt(false);
    setModifiers([]);
    setContextInfo("");
    setMode("code");
    setDetailLevel("balanced");
    setOutputFormat("structured");
    setActiveHistoryId(null);
    setToast("Ready for a new prompt!");
    setTimeout(() => setToast(null), 2000);
  }, [isListening, stopListening, resetTranscript]);

  return (
    <div className="relative z-10 min-h-screen pb-24 md:pb-8">
      {/* History Sidebar */}
      <PromptHistory
        history={history}
        activeId={activeHistoryId}
        onSelect={handleHistorySelect}
        onDelete={handleHistoryDelete}
        onClear={handleHistoryClear}
        isOpen={historyOpen}
        onToggle={() => setHistoryOpen(!historyOpen)}
      />

      <div className={`max-w-3xl mx-auto transition-all duration-300 ${historyOpen ? "md:ml-80" : ""}`}>
        {/* Header */}
        <Header />

        {/* Browser Warning */}
        {showBrowserWarning && <BrowserWarning />}

        {/* Voice Recorder */}
        <VoiceRecorder
          isListening={isListening}
          isSupported={isSupported}
          interimTranscript={interimTranscript}
          onStart={startListening}
          onStop={stopListening}
        />

        {/* Transcript Editor */}
        <TranscriptEditor
          value={transcript}
          onChange={setTranscript}
          onClear={handleClear}
          isListening={isListening}
        />

        {/* Divider */}
        <div className="px-4 md:px-0 py-2">
          <div className="h-px bg-gradient-to-r from-transparent via-border-subtle to-transparent" />
        </div>

        {/* Prompt Mode Selector */}
        <PromptModeSelector selected={mode} onChange={setMode} />

        {/* Modifier Checkboxes */}
        <ModifierCheckboxes selected={modifiers} onChange={setModifiers} />

        {/* Detail Level and Output Format */}
        <div className="px-4 md:px-0 py-4 flex flex-col md:flex-row gap-4">
          <DetailLevelSelector selected={detailLevel} onChange={setDetailLevel} />
          <OutputFormatSelector selected={outputFormat} onChange={setOutputFormat} />
        </div>

        {/* Context Input */}
        <ContextInput value={contextInfo} onChange={setContextInfo} />

        {/* Action Buttons */}
        <div className="px-4 md:px-0 py-4 flex gap-3">
          <button
            onClick={handleGenerate}
            disabled={!transcript.trim() || isGenerating}
            className="flex-1 py-3.5 rounded-xl bg-gradient-to-r from-claude-orange to-claude-coral text-white font-bold text-base transition-all hover:brightness-110 hover:shadow-lg hover:shadow-claude-orange/20 active:scale-[0.99] disabled:opacity-40 disabled:cursor-not-allowed disabled:hover:brightness-100 disabled:hover:shadow-none cursor-pointer"
          >
            {isGenerating ? (
              <span className="flex items-center justify-center gap-2">
                <svg className="w-5 h-5 animate-spin" fill="none" viewBox="0 0 24 24">
                  <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
                  <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z" />
                </svg>
                Generating with Opus 4.5...
              </span>
            ) : (
              <span className="flex items-center justify-center gap-2">
                <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                  <path strokeLinecap="round" strokeLinejoin="round" d="M13 10V3L4 14h7v7l9-11h-7z" />
                </svg>
                Generate Prompt
              </span>
            )}
          </button>

          {/* Interview Mode Button */}
          <button
            onClick={() => setShowInterview(true)}
            disabled={!transcript.trim() || isGenerating}
            className="px-5 py-3.5 rounded-xl bg-bg-card border-2 border-accent-purple/50 text-accent-purple font-semibold text-sm transition-all hover:bg-accent-purple/10 hover:border-accent-purple active:scale-[0.98] disabled:opacity-40 disabled:cursor-not-allowed cursor-pointer flex items-center gap-2"
            title="AI-assisted interview to refine your prompt"
          >
            <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
            </svg>
            <span className="hidden sm:inline">Interview</span>
          </button>
        </div>

        {/* Prompt Preview */}
        <PromptPreview prompt={generatedPrompt} isVisible={showPrompt} />

        {/* Action Bar */}
        <ActionBar
          prompt={generatedPrompt}
          copied={copied}
          onCopy={handleCopy}
          onReset={handleReset}
        />
      </div>

      {/* Interview Modal */}
      <InterviewModal
        isOpen={showInterview}
        onClose={() => setShowInterview(false)}
        onComplete={handleInterviewComplete}
        initialTranscript={transcript}
        mode={mode}
      />

      {/* Toast notification */}
      {toast && (
        <div className="fixed top-4 left-1/2 -translate-x-1/2 z-[100] animate-fade_in">
          <div className="bg-bg-card border border-claude-orange/30 text-text-primary px-5 py-3 rounded-xl shadow-xl shadow-claude-orange/10 text-sm font-medium flex items-center gap-2">
            <span className="w-2 h-2 bg-claude-orange rounded-full" />
            {toast}
          </div>
        </div>
      )}
    </div>
  );
}
